/**
 * Java8 Grammar
 *
 *  Based on grammar from Java8 language specification
 *
 * [1] https://docs.oracle.com/javase/specs/jls/se8/html/jls-2.html#jls-2.4
 *
 * Authors:
 *   Kimio Kuramitsu (https://github.com/kkuramitsu/)
 *   Kohei Moriya
 */
File           = _ {
	 $(PackageDeclaration)? 
	 $(ImportDeclaration)* 
	 $(TypeDeclaration)* 
	 #Source 
} _ EOT

/* Code Layout (Whitespace) */
_            = ( S / BLOCKCOMMENT / LINECOMMENT )*
__           = !S
S            = [ \n\r\t\u000B\u000C]
BLOCKCOMMENT = '/*' ( !'*/' . )* '*/'
LINECOMMENT  = '//' ( !'\n' . )*
EOL          = '\r'? '\n'
             / !.
EOT          = !.

/* Operators */
"++"         = '++' _
"--"         = '--' _
"&"          = '&' ![&=] _
"*"          = '*' !'=' _
"+"          = '+' ![+=] _
"-"          = '-' !( '-' / [=>] ) _
"~"          = '~' _
"!"          = '!' !'=' _
"{"          = '{' _
"["          = '[' _
"]"          = ']' _
","          = ',' _
"..."        = '...' _
":"          = ':' ![>:] _
"::"         = '::' _
"/"          = '/' !'=' _
"%"          = '%' ![=>] _
"<<"         = '<<' !'=' _
">>"         = '>>' ![=>] _
">>>"        = '>>>' !'=' _
"<="         = '<=' _
">="         = '>=' _
"<"          = '<' ![=] _
">"          = '>' ![=] _
"=="         = '==' _
"!="         = '!=' _
"^"          = '^' ![=] _
"|"          = '|' ![|=] _
"&&"         = '&&' _
"||"         = '||' _
"?"          = '?' _
";"          = ';' _
"}"          = '}' _
"*="         = '*=' _
"/="         = '/=' _
"%="         = '%=' _
"+="         = '+=' _
"-="         = '-=' _
"<<="        = '<<=' _
">>="        = '>>=' _
">>>="       = '>>>=' _
"&="         = '&=' _
"^="         = '^=' _
"|="         = '|=' _
"="          = '=' !'=' _
"."          = '.' !'.' _
"("          = '(' _
")"          = ')' _
"@"          = '@' _
"->"         = '->' _

// reserved keyword
"abstract"     = 'abstract' !W _
"assert"       = 'assert' !W _
"boolean"      = 'boolean' !W _
"break"        = 'break' !W _
"byte"         = 'byte' !W _
"case"         = 'case' !W _
"catch"        = 'catch' !W _
"char"         = 'char' !W _
"class"        = 'class' !W _
"const"        = 'const' !W _
"continue"     = 'continue' !W _
"default"      = 'default' !W _
"do"           = 'do' !W _
"double"       = 'double' !W _
"else"         = 'else' !W _
"enum"         = 'enum' !W _
"extends"      = 'extends' !W _
"false"        = 'false' !W _
"final"        = 'final' !W _
"finally"      = 'finally' !W _
"float"        = 'float' !W _
"for"          = 'for' !W _
"goto"         = 'goto' !W _
"if"           = 'if' !W _
"implements"   = 'implements' !W _
"import"       = 'import' !W _
"instanceof"   = 'instanceof' !W _
"int"          = 'int' !W _
"interface"    = 'interface' !W _
"long"         = 'long' !W _
"native"       = 'native' !W _
"new"          = 'new' !W _
"null"         = 'null' !W _
"package"      = 'package' !W _
"private"      = 'private' !W _
"protected"    = 'protected' !W _
"public"       = 'public' !W _
"return"       = 'return' !W _
"short"        = 'short' !W _
"static"       = 'static' !W _
"strictfp"     = 'strictfp' !W _
"super"        = 'super' !W _
"switch"       = 'switch' !W _
"synchronized" = 'synchronized' !W _
"this"         = 'this' !W _
"throw"        = 'throw' !W _
"throws"       = 'throws' !W _
"transient"    = 'transient' !W _
"true"         = 'true' !W _
"try"          = 'try' !W _
"void"         = 'void' !W _
"volatile"     = 'volatile' !W _
"while"        = 'while' !W _
KEYWORD        = "abstract"
               / "assert"
               / "boolean"
               / "break"
               / "byte"
               / "case"
               / "catch"
               / "char"
               / "class"
               / "const"
               / "continue"
               / "default"
               / "double"
               / "do"
               / "else"
               / "enum"
               / "extends"
               / "false"
               / "final"
               / "finally"
               / "float"
               / "for"
               / "goto"
               / "if"
               / "implements"
               / "import"
               / "instanceof"
               / "interface"
               / "int"
               / "long"
               / "native"
               / "new"
               / "null"
               / "package"
               / "private"
               / "protected"
               / "public"
               / "return"
               / "short"
               / "static"
               / "strictfp"
               / "super"
               / "switch"
               / "synchronized"
               / "this"
               / "throws"
               / "throw"
               / "transient"
               / "true"
               / "try"
               / "void"
               / "volatile"
               / "while"

/* Modifiers, Annotation */

AModifiers = { $(AModifier)+ #Modifiers }
AModifier = Annotation
          / "public"    { #Public }
          / "protected" { #Protected }
          / "private"   { #Private }
          / "abstract"  { #Abstract }
          / "final"     { #Final }
          / "static"    { #Static }
          / "strictfp"  { #Strictfp }

Annotations = { 
	$(Annotation)+ 
	#Modifiers 
}

Annotation = { "@"
	$name(QualifiedName) 
	"(" $value(ElementValuePairList)? ")" 
	#Annotation 
} / { "@"
	$name(QualifiedName) 
	"(" $value(ElementValue) ")" 
	#Annotation 
} / { "@"
	$name(QualifiedName) 
	#Annotation 
}

ElementValuePairList = { 
	$(ElementValuePair) ( "," $(ElementValuePair) )* 
}
ElementValuePair = { 
	$name(Identifier) 
	"=" 
	$value(ElementValue) 
	#KeyValue 
}
ElementValue = ElementValueArrayInitializer
             / ConditionalExpression
             / Annotation
ElementValueArrayInitializer = {
	"{" 
	($(ElementValue) ( "," $(ElementValue) )*)? 
	","? "}" 
} 

// Annotation
example File '''
@Entity                                             // Declares this an entity bean
@Table(name = "people")                             // Maps the bean to SQL table "people"
public class Person implements Serializable {
    @Id                                             // Map this to the primary key column.
    @GeneratedValue(strategy = GenerationType.AUTO) // Database will generate new primary keys, not us.
    private Integer id;

    @Column(length = 32)                            // Truncate column values to 32 characters.
    private String name;
}
'''


/* Declaration */
// package
PackageDeclaration = { 
	$anno(Annotations)? 
	"package" 
	$name(QualifiedName) 
	#PackageDecl 
} ";"

// import
ImportDeclaration = {
	"import" ("static" #StaticImportDecl / #ImportDecl) 
	$path(PackageName) 
} ";"
PackageName = QualifiedName {$ "." "*" #WildCardName }?

// top-level

OrigamiTopLevel = AssertStatement
                / BlockStatement
                / ";" { #MultiStmt }

AssertStatement = {
	"assert"
	$cond(Expression) 
	( ":" $value(Expression) )? 
	#AssertStmt
}

// type
TypeDeclaration = ClassDeclaration
                / EnumDeclaration
                / InterfaceDeclaration

// class, enum
ClassDeclaration = { 
	$anno(ClassModifiers)? 
	"class" 
	$name(Identifier) 
	$param(TypeParameters)? 
	$super(SuperClass)? 
	$impl(SuperInterfaces)? 
	$body(ClassBody) 
	#ClassDecl 
}

EnumDeclaration = { 
	$anno(ClassModifiers)?
	"enum" $name(Identifier) 
	$impl(SuperInterfaces)? 
	$body(EnumBody) 
	#EnumDecl 
}
ClassModifiers = { $(ClassModifier)+ #Modifiers }
ClassModifier = Annotation
              / "public"    { #Public }
              / "protected" { #Protected }
              / "private"   { #Private }
              / "abstract"  { #Abstract }
              / "final"     { #Final }
              / "static"    { #Static }
              / "strictfp"  { #Strictfp }
SuperClass = "extends" ClassOrInterfaceType
SuperInterfaces = "implements" ClassOrInterfaceTypes
ClassBody = "{" { $(ClassBodyDeclaration)* #BlockStmt } "}"
ClassBodyDeclaration = ClassMemberDeclaration
                     / { $(Block) #JavaInstanceInisializer }
                     / "static" { $(Block) #JavaStaticInitializer }
                     / ConstructorDeclaration
ClassMemberDeclaration = FieldDeclaration
                       / MethodDeclaration
                       / ClassDeclaration
                       / InterfaceDeclaration
                       / ";" { #MultiStmt }
EnumBody = "{" { addEnumeratorList? ","? ";" $({ $(ClassBodyDeclaration)+ #JavaEnumMemberList }) #List } "}"
         / "{" { addEnumeratorList? ","? ";"? #List } "}"
addEnumeratorList = $(Enumerator) ( "," $(Enumerator) )*
Enumerator = { $anno(Annotations)? $name(Identifier) $(ArgumentExpressionList) $(ClassBody)? #JavaEnumerator }
           / { $anno(Annotations)? $name(Identifier) $(ClassBody) #JavaEnumerator }
           / { $anno(Annotations)? $name(Identifier) #Enumerator }

// interface, annotation
InterfaceDeclaration = { $anno(InterfaceModifiers)? "interface" $name(Identifier) $_(TypeParameters)? $super(ExtendsInterfaces)? $body(InterfaceBody) #InterfaceDecl }
                     / { $(InterfaceModifiers)? "@" "interface" $(Identifier) $(AnnotationTypeBody) #JavaAnnotationTypeDecl }
InterfaceModifiers   = { $(InterfaceModifier)+ #Modifiers }
InterfaceModifier    = Annotation
                     / "public"    { #Public }
                     / "protected" { #Protected }
                     / "private"   { #Private }
                     / "abstract"  { #Abstract }
                     / "static"    { #Static }
                     / "strictfp"  { #Strictfp }
ExtendsInterfaces    = "extends" ClassOrInterfaceTypes
InterfaceBody        = "{" { $(InterfaceMemberDeclaration)* #BlockStmt } "}"
InterfaceMemberDeclaration = ConstantDeclaration
                           / InterfaceMethodDeclaration
                           / ClassDeclaration
                           / InterfaceDeclaration
                           / ";" { #MultiStmt }
AnnotationTypeBody = "{" { $(AnnotationTypeMemberDeclaration)* #BlockStmt } "}"
AnnotationTypeMemberDeclaration = AnnotationTypeElementDeclaration
                                / ConstantDeclaration
                                / ClassDeclaration
                                / InterfaceDeclaration
                                / ";" { #MultiStmt }
AnnotationTypeElementDeclaration = { $(AnnotationTypeElementModifiers)? $(Type) $(Identifier) "(" ")" $(AnnotationTypeElementDefaultValue)? ";" #JavaAnnotationTypeElement }
AnnotationTypeElementModifiers = { $(AnnotationTypeElementModifier)+ #Modifiers }
AnnotationTypeElementModifier = Annotation
                              / "public"   { #Public }
                              / "abstract" { #Abstract }
AnnotationTypeElementDefaultValue = "default" ElementValue

// local variable
VariableDeclaration = { 
	$anno(VariableModifiers)? 
	$type(Type) 
	addVariableDeclarations 
}
VariableModifiers = { 
	$(VariableModifier)+ #Modifiers 
}
VariableModifier = Annotation
                 / "final" { #Final }
addVariableDeclarations = $name(VarName) ( "=" $expr(Initializer) )? !',' #VarDecl
                        / $list(InitDeclList) #MultiVarDecl

InitDecl = { $name(VarName) ( "=" $expr(Initializer) )? #VarDecl }
InitDeclList = { $(InitDecl) ( "," $(InitDecl) )* #List }
VarName = Identifier {$name "[" $param(ConstantExpression)? "]" #ArrayName }*
Initializer = Expression
            / ArrayInitializer
ArrayInitializer = { 
	"{" 
	( $(Initializer) ( "," $(Initializer) )* )? ","? 
	"}" 
	#ArrayExpr
}

//field
FieldDeclaration = { $anno(FieldModifiers)? $type(Type) $list(InitDeclList) #FieldDecl } ";"
FieldModifiers = { $(FieldModifier)+ #Modifiers }
FieldModifier = Annotation
              / "public"    { #Public }
              / "protected" { #Protected }
              / "private"   { #Private }
              / "final"     { #Final }
              / "static"    { #Static }
              / "transient" { #Transient }
              / "volatile"  { #Volatile }

//constant
ConstantDeclaration = { $anno(ConstantModifiers)? $type(Type) $list(InitDeclList) #JavaInterfaceConstantDecl } ";"
ConstantModifiers = { $(ConstantModifier)+ #Modifiers }
ConstantModifier = Annotation
                 / "public" { #Public }
                 / "final"  { #Final }
                 / "static" { #Static }

//method
MethodDeclaration = { $anno(MethodModifiers)? ( $(TypeParameters) $anno(Annotations)? )? $type(TypeOrVoid) $name(Identifier) "(" $param(MethodParamList) ")" $throws(Throws)? ($body(Block) / ";") #MethodDecl }
MethodModifiers = { $(MethodModifier)+ #Modifiers }
MethodModifier = Annotation
               / "public"       { #Public }
               / "protected"    { #Protected }
               / "private"      { #Private }
               / "abstract"     { #Abstract }
               / "final"        { #Final }
               / "static"       { #Static }
               / "synchronized" { #Synchronized }
               / "native"       { #Native }
               / "strictfp"     { #Strictfp }

InterfaceMethodDeclaration = { $anno(InterfaceMethodModifiers)? ( $(TypeParameters) $anno(Annotations)? )? $type(TypeOrVoid) $name(Identifier) "(" $param(MethodParamList) ")" $throws(Throws)? ($body(Block) / ";") #MethodDecl }
InterfaceMethodModifier = Annotation
                        / "public"   { #Public }
                        / "abstract" { #Abstract }
                        / "default"  { #Default }
                        / "static"   { #Static }
                        / "strictfp" { #Strictfp }
InterfaceMethodModifiers = { $(InterfaceMethodModifier)+ #Modifiers }
MethodParamList = { ( $(MethodParam) "," )* $(VarParam) #List }
                / { ( $(MethodParam) ( "," $(MethodParam) )* )? #List }
MethodParam = { $anno(VariableModifiers)? $type(Type) $name(VarName) #Param }
VarParam = { $anno(VariableModifiers)? $(Type) "..." $(VarName) #VarParam }
Throws = "throws" { $(ClassOrInterfaceTypes) #Throws }

//constructor
ConstructorDeclaration = { $anno(ConstructorModifiers)? $type(ReferenceType) "(" $param(MethodParamList) ")" $throws(Throws)? $body(ConstructorBody) #ConstructorDecl }
ConstructorModifiers = { $(ConstructorModifier)+ #Modifiers }
ConstructorModifier = Annotation
                                   / "public"    { #Public }
                                   / "protected" { #Protected }
                                   / "private"   { #Private }
ConstructorBody                    = "{" { $(ExplicitConstructorInvocation)? $(BlockStatement)* #BlockStmt } "}"
ExplicitConstructorInvocation      = { $type(TypeArguments)? $name(This) $param({ "(" addArgumentExpressionList? ")" #List }) #ExplicitConstructorInvocation } ";"
                                   / { $type(TypeArguments)? $name(Super) $param({ "(" addArgumentExpressionList? ")" #List }) #ExplicitConstructorInvocation } ";"
                                   / { $recv(PostfixExpression) "." $type(TypeArguments)? $name(Super) $param({ "(" addArgumentExpressionList? ")" #List }) #ExplicitConstructorInvocation } ";"

/* Types, Values, Variables */
Type                = ReferenceType
                    / PrimitiveType
PrimitiveType       = { $anno(Annotations) $(UnannoPrimitiveType) #Annotated }
                    / UnannoPrimitiveType
UnannoPrimitiveType = NumericType
                    / BooleanType
NumericType         = IntegralType
                    / FloatingPointType
IntegralType        = {( 'byte'
                    / 'char'
                    / 'short'
                    / 'int'
                    / 'long') #ClassType }
                                   !W _
FloatingPointType   = {( 'float'
                    / 'double') #ClassType }
                                   !W _
BooleanType         = {'boolean' #ClassType } !W _
ReferenceType       = ArrayType
                    / ClassOrInterfaceType
                    / TypeVariable
ArrayType           = (PrimitiveType / ClassOrInterfaceType / TypeVariable) {$base $(Annotations)? "[" "]" #ArrayType }+
ClassOrInterfaceType= ClassType
                    / InterfaceType
ClassType           = SimpleClassType {$prefix "." $name(SimpleClassType) #PackageClassType }*
SimpleClassType     = { $anno(Annotations) $(UnannoSimpleClassType) #Annotated }
                    / UnannoSimpleClassType
UnannoSimpleClassType              = ClassIdentifier {$base $param(TypeArguments) #GenericType }?
ClassIdentifier     = { NAME #ClassType } _
InterfaceType       = ClassType
TypeVariable        = { $anno(Annotations) $(Identifier) #Annotated }
                    / Identifier
TypeParameter       = { $anno(Annotations) $(UnannoTypeParameter) #Annotated }
                    / UnannoTypeParameter
UnannoTypeParameter = Identifier {$base "extends" $extends(ClassOrInterfaceType) ( "&" $(InterfaceType) )* #TypeBound }?
TypeParameters      = { "<" $(TypeParameter) ( "," $(TypeParameter) )* ">" #TypeLists }
TypeArgument        = ReferenceType
                    / { $(Annotations)? "?" #TWildCard } {$ ("extends" #UpperBound / "super" #LowerBound) $(ReferenceType) }?
TypeArguments       = { "<" ( $(TypeArgument) ( "," $(TypeArgument) )* )? ">" #TypeArguments }
Void                = { "void" `void` #ClassType }
TypeOrVoid          = Type
                    / Void
NonArrayType        = ClassOrInterfaceType
                    / PrimitiveType
ClassOrInterfaceTypes              = { $(ClassOrInterfaceType) ( "," $(ClassOrInterfaceType) )* #List }

// Block, Statement
//===================
Block = {
	"{" 
	$(BlockStatement)* 
	#BlockStmt 
	"}" 
}

BlockStatement = Statement
               / VariableDeclaration ";"
               / ClassDeclaration

Statement = Block
          / { "assert" $cond(Expression) ( ":" $value(Expression) )? #AssertStmt } ";"
          / { "if" "(" $cond(Expression) ")" $then(Statement) ( "else" $else(Statement) )? #IfStmt }
          / SwitchStatement
          / { "while" "(" $cond(Expression) ")" $body(Statement) #ForStmt }
          / { "do" $body(Statement) "while" "(" $cond(Expression) ")" #DoWhileStmt } ";"
          / { "for" "(" $init(Expressions)? ";" $cond(Expression)? ";" $iter(Expressions)? ")" $body(Statement) #ForStmt }
          / { "for" "(" $init(VariableDeclaration) ";" $cond(Expression)? ";" $iter(Expressions)? ")" $body(Statement) #ForStmt }
          / { "for" "(" $anno(VariableModifiers)? $type(Type) $name(Identifier) ":" $iter(Expression) ")" $body(Statement) #ForEachStmt }
          / { "continue" $label(Identifier)? `` #ContinueStmt } ";"
          / { "break" $label(Identifier)? `` #BreakStmt } ";"
          / { "return" $expr(Expression)? #ReturnStmt } ";"
          / TryStatement
          / { "throw" $expr(Expression) #ThrowStmt } ";"
          / { "synchronized" "(" $cond(Expression) ")" $body(Block) #SynchronizedStmt }
          / { $label(Identifier) ":" $body(Statement) #LabelStmt }
          / Expression ";"
          / ";" { #MultiStmt }

// try-catch-finally
TryStatement = { "try" $list(ResourceList) $try(Block) $catch({ $(Catch)* #List }) ( "finally" $finally(Block) )? #JavaTryWithResource }
             / { "try" $try(Block) $catch({ $(Catch)* #List }) "finally" $finally(Block) #TryStmt }
             / { "try" $try(Block) $catch({ $(Catch)+ #List }) #TryStmt }
ResourceList = "(" { $(Resource) ( ";" $(Resource) )* #JavaResourceList } ";"? ")"
Resource     = { $anno(VariableModifiers)? $type(Type) $name(Identifier) "=" $expr(Expression) #VarDecl }
Catch        = { "catch" "(" CATCH_PARAM ")" $body(Block) #CatchClause }
CATCH_PARAM  = $anno(VariableModifiers)? $type(ClassOrInterfaceType) $name(Identifier)
             / $anno(VariableModifiers)? $type({ $(ClassOrInterfaceType) ( "|" $(ClassOrInterfaceType) )+ #JavaMultiExceptions }) $name(Identifier)

// switch
SwitchStatement = { "switch" "(" $cond(Expression) ")" $body(SwitchBlock) #SwitchStmt }
SwitchBlock     = "{" { $(SwitchCondition)+ #Block } "}"
SwitchCondition = { "case" $cond(ConstantExpression) ":" $body(CaseBlock) #SwitchCase }
                / { "default" ":" $body(CaseBlock) #SwitchDefault }
CaseBlock       = { $(BlockStatement)* #BlockStmt }


/* Expression */
Expression = LambdaExpression
           / AssignmentExpression
Expressions = { $(Expression) ( "," $(Expression) )* #MultiExpr }

AssignmentExpression = {
	 $left(UnaryExpression) 
	 ASSIGN_OP 
	 $right(Expression) 
} / ConditionalExpression

ASSIGN_OP = "=" #AssignExpr
          / "*=" #MulAssign
          / "/=" #DivAssign
          / "%=" #ModAssign
          / "+=" #AddAssign
          / "-=" #SubAssign
          / "<<=" #LShiftAssign
          / ">>=" #RShiftAssign
          / ">>>=" #LRShiftAssign
          / "&=" #BitwiseAndAssign
          / "^=" #BitwiseXorAssign
          / "|=" #BitwiseOrAssign

ConstantExpression = ConditionalExpression
ConditionalExpression = LogicalOrExpression {$cond "?" $then(Expression) ":" $else(LogicalOrExpression) #IfExpr }*
LogicalOrExpression = LogicalAndExpression {$left "||" $right(LogicalAndExpression) #OrExpr }*
LogicalAndExpression = InclusiveOrExpression {$left "&&" $right(InclusiveOrExpression) #AndExpr }*
InclusiveOrExpression = ExclusiveOrExpression {$left "|" $right(ExclusiveOrExpression) #BitwiseOrExpr }*
ExclusiveOrExpression = AndExpression {$left "^" $right(AndExpression) #BitwiseXorExpr }*
AndExpression = EqualityExpression {$left "&" $right(EqualityExpression) #BitwiseAndExpr }*
EqualityExpression = RelationalExpression {$left ("==" #EqExpr / "!=" #NeExpr) $right(RelationalExpression) }*
RelationalExpression = ShiftExpression {$left addRelationalOperator }*
addRelationalOperator = "<=" $right(ShiftExpression) #LteExpr
                      / ">=" $right(ShiftExpression) #GteExpr
                      / "<" $right(ShiftExpression) #LtExpr
                      / ">" $right(ShiftExpression) #GtExpr
                      / "instanceof" $right(ReferenceType) #InstanceOfExpr
ShiftExpression = AdditiveExpression {$left ("<<" #LShiftExpr / ">>" #RShiftExpr / ">>>" #LRShiftExpr) $right(AdditiveExpression) }*
AdditiveExpression = MultiplicativeExpression {$left ("+" #AddExpr / "-" #SubExpr) $right(MultiplicativeExpression) }*
MultiplicativeExpression = CastNewExpression {$left ("*" #MulExpr / "/" #DivExpr / "%" #ModExpr) $right(CastNewExpression) }*
CastNewExpression = { "(" $type(Type) ")" $expr(CastNewExpression) #CastExpr }
                  / UnaryExpression
UnaryExpression = PostfixExpression
                / { "++" $expr(UnaryExpression) #IncExpr }
                / { "--" $expr(UnaryExpression) #DecExpr }
                / { "+" $expr(CastNewExpression) #PlusExpr }
                / { "-" $expr(CastNewExpression) #MinusExpr }
                / { "~" $expr(CastNewExpression) #ComplExpr }
                / { "!" $expr(CastNewExpression) #NotExpr }
                
PostfixExpression = PrimaryExpression ({$recv addMethodCall / addInstanceCreation / addIndex / addField / addMethodReference } / {$expr addInc / addDec })*
addMethodCall = "." $(TypeArguments)? $name(Identifier) $param(ArgumentExpressionList) #MethodExpr
addInstanceCreation = "." "new" $(TypeArguments)? $(Annotations)? $name(ClassOrInterfaceType) $param(ArgumentExpressionList) $body(ClassBody)? #NewClassExpr
ArgumentExpressionList = { "(" addArgumentExpressionList? ")" #List }
addArgumentExpressionList = $(Expression) ( "," $(Expression) )*
addIndex                  = "[" $param({ $(Expression) #List }) "]" #IndexExpr
addField                  = "." $name(Identifier) !'(' #GetExpr
addMethodReference        = "::" $(TypeArguments)? $(Identifier) #JavaMethodReference
addInc                    = "++" #PostIncExpr
addDec                    = "--" #PostDecExpr

PrimaryExpression = Constant
                  / This
                  / Super
                  / "(" Expression ")"
                  / ClassLiteral
                  / { $(QualifiedName) "." "this" #JavaThis }
                  / { $(QualifiedName) "." "super" #JavaSuper }
                  / MethodInvocationExpression
                  / InstanceCreationExpression
                  / ArrayCreationExpression
                  / MethodReference
                  / Identifier

ClassLiteral = { $(TypeOrVoid) "." "class" #TypeLiteralExpr }
This         = "this" { #ThisExpr }
Super        = "super" { #SuperExpr }
MethodInvocationExpression = { $recv(Identifier) $param(ArgumentExpressionList) #ApplyExpr }
InstanceCreationExpression = { "new" $({ $(TypeArguments) #JavaTypeArgs })? $(Annotations)? $type(ClassOrInterfaceType) $param(ArgumentExpressionList) $body(ClassBody)? #NewExpr }
ArrayCreationExpression  = { "new" $(Annotations)? $type(NonArrayType {$base $(Annotations)? "[" $size(Expression) "]" #ArrayType }+ {$base $(Annotations)? "[" "]" #ArrayType }*) #NewArrayExpr }
                         / { "new" $(Annotations)? $type(NonArrayType {$base $(Annotations)? "[" "]" #ArrayType }+) $expr(ArrayInitializer) #NewArrayExpr }
MethodReference = { $(ReferenceType) "::" $(TypeArguments)? $(Identifier / { "new" #Name }) #JavaMethodReference }

/* Lambda */
LambdaExpression = { $param(LambdaParameters) "->" $body(LambdaBody) #FuncExpr }
LambdaParameters = Identifier
                 / "(" MethodParamList ")"
                 / "(" InferredParamList ")"
InferredParamList = { $(Identifier) ( "," $(Identifier) )* #List }
LambdaBody = !'{' { $({ $expr(Expression) #ReturnStmt }) #BlockStmt }
           / Block

/* Identifier */
Identifier = { NAME #NameExpr } _
QualifiedName = Identifier {$ "." $(Identifier) #QualifiedName }*
W = [a-zA-Z0-9_$]
NAME = !DIGIT !KEYWORD W+

/* Literal, Constant */
Literal        = FloatingPointLiteral
               / IntegerLiteral
               / BooleanLiteral
               / CharacterLiteral
               / StringLiteral
               / NullLiteral
Constant       = Literal
NullLiteral    = "null" { #NullExpr }
BooleanLiteral = "true" { #TrueExpr }
               / "false" { #FalseExpr }

IntegerLiteral = { (DECIMAL / HEXADECIMAL / BINARY / OCTAL) (INT_SUFFIX #LongExpr / #IntExpr) } _
DIGIT          = [0-9]
DIGITS         = DIGIT ( '_'* DIGIT )*
DECIMAL        = '0' ![bBxX0-9_]
               / !'0' DIGITS
HEXDIGIT       = [a-fA-F0-9]
HEXDIGITS      = HEXDIGIT ( '_'* HEXDIGIT )*
HEXADECIMAL    = '0' [xX] HEXDIGITS
BINARYDIGIT    = [01]
BINARYDIGITS   = BINARYDIGIT ( '_'* BINARYDIGIT )*
BINARY         = '0' [bB] BINARYDIGITS
OCTALDIGIT     = [0-7]
OCTAL          = '0' ( '_'* OCTALDIGIT )*
INT_SUFFIX     = [lL]
FloatingPointLiteral               = { FLOAT (FLOAT_SUFFIX #FloatExpr / DOUBLE_SUFFIX? #DoubleExpr) } _
               / { DIGITS (FLOAT_SUFFIX #FloatExpr / DOUBLE_SUFFIX #DoubleExpr) } _
FLOAT_SUFFIX   = [fF]
DOUBLE_SUFFIX  = [dD]
FLOAT          = FRACTION EXPONENT?
               / DIGITS EXPONENT
               / HEXFRACTION BINARYEXPONENT
EXPONENT       = [eE] [+\-]? DIGITS
BINARYEXPONENT = [pP] [+\-]? DIGITS
FRACTION       = '.' DIGITS
               / DIGITS '.' DIGITS?
HEXFRACTION    = '0' [xX] '.' HEXDIGITS
               / HEXADECIMAL ( '.' HEXDIGITS? )?
StringLiteral  = '"' { STRING_CONTENT* #StringExpr } '"' _
CharacterLiteral                   = '\'' { CHAR_CONTENT #CharExpr } '\'' _
STRING_CONTENT = ESCAPE
               / ![\"\n\\] .
CHAR_CONTENT   = ESCAPE
               / !['\n\\] .
ESCAPE         = SIMPLE_ESCAPE
               / OCTAL_ESCAPE
               / HEX_ESCAPE
SIMPLE_ESCAPE  = '\\' ['\"\\bfnrt]
OCTAL_ESCAPE   = '\\' [0-3] OCTALDIGIT OCTALDIGIT
               / '\\' OCTALDIGIT OCTALDIGIT
               / '\\' OCTALDIGIT
HEX_ESCAPE     = '\\' 'u'+ HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT

/* Example */

// The traditional "Hello, world!" program can be written in Java
example TypeDeclaration&File '''
class HelloWorldApp {
    public static void main(String[] args) {
        System.out.println("Hello World!"); // Prints the string to the console.
    }
}
'''

// Generics
example File '''
package java.util.List;
public interface List<E> {
    void add(E x);
    Iterator<E> iterator();
}
'''


// Generic Method
example MethodDeclaration '''
public void doSomething(List<? extends MyClass> list) {
  for(MyClass object : list) { // OK
    // do something
  }
}
'''

// Generic Method
example MethodDeclaration '''
public static <Type> Entry<Type, Type> twice(Type value) {
    return new Entry<Type, Type>(value, value);
}
'''

// Generics in throws clause
example MethodDeclaration '''
public <T extends Throwable> void throwMeConditional(boolean conditional, T exception) throws T {
    if(conditional) {
        throw exception;
    }
}
'''

/* Variable Declraration */

example VariableDeclaration '''
int a = 1
'''

example VariableDeclaration '''
int a = 1, b
'''

example VariableDeclaration '''
int[] anArray = {
    1, 2,
    3, 4
}
'''

example VariableDeclaration '''
String[][] names = {
  {"Mr. ", "Mrs. ", "Ms. "},
  {"Smith", "Jones"}
}
'''

/* Statement */

example Statement '''
if(c);
'''

example Statement '''
if(c) {
}
'''

/* Expression (standard) */

example Expression ~7d9419 '''
1+2*3
'''

example Expression ~bfe331 '''
1*2+3
'''

example Expression ~162311 '''
(1+2)*3
'''

example Expression ~cd4f5d '''
1+2-3*4%5
'''

example Expression '''
x = x + 1
'''

example Expression '''
x = x | 1
'''

example Expression '''
x = x & 1
'''


/* Expression (local) */

example Expression '''
() -> {
  System.out.println("example");
}
'''

/* Identifier (standard) */

example Expression ~a47e9fd '''
x
'''

example Expression  ~fdb051 '''
Apple
'''

/* Literal (standard) */

example Literal ~1e4f2d '''
true
'''

example Literal ~4eab66 '''
false
'''

example Literal ~ec2775 '''
'C'
'''

example Literal ~1951c6 '''
0
'''

example Literal ~aef181 '''
26
'''

example Literal ~c3b9d6 '''
0x1a
'''

example Literal ~146f59 '''
0b11010
'''

example Literal ~f74a78 '''
123.4
'''

example Literal ~94b99c '''
1.234e2
'''

example Literal ~c83c217 '''
123.4f
'''

example Literal ~02bf7f6 '''
"hello,world\n"
'''

/* Literal (standard) */

example Literal ~db9f5e3 '''
"S\u00ED Se\u00F1or"
'''
